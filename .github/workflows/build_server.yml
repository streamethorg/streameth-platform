name: Build server

on:
  push:
    branches: [docker, docker-prod]

jobs:
  prepare-env:
    runs-on: ubuntu-latest
    outputs:
      env_tag: ${{ steps.set-tag.outputs.ENV_TAG }}
      compose_file: ${{ steps.set-tag.outputs.COMPOSE_FILE }}
      stack_name: ${{ steps.set-tag.outputs.STACK_NAME }}
    steps:
      - name: Set environment tag
        id: set-tag
        run: |
          if [[ ${{ github.ref }} == 'refs/heads/docker-prod' ]]; then
            echo "ENV_TAG=prod" >> $GITHUB_OUTPUT
            echo "COMPOSE_FILE=docker-compose.prod.yml" >> $GITHUB_OUTPUT
            echo "STACK_NAME=prod" >> $GITHUB_OUTPUT
          else
            echo "ENV_TAG=staging" >> $GITHUB_OUTPUT
            echo "COMPOSE_FILE=docker-compose.staging.yml" >> $GITHUB_OUTPUT
            echo "STACK_NAME=streameth-staging" >> $GITHUB_OUTPUT
          fi

  build-and-push-images:
    needs: prepare-env
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - image: server
            dockerfile: ./packages/server/src/Dockerfile
          - image: stage-transcriptions
            dockerfile: ./packages/server/workers/stage-transcriptions/Dockerfile
          - image: session-transcriptions
            dockerfile: ./packages/server/workers/session-transcriptions/Dockerfile
          - image: clips
            dockerfile: ./packages/server/workers/clips/Dockerfile
          - image: reel-creator
            dockerfile: ./packages/reel-creator/Dockerfile
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ matrix.image }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-${{ matrix.image }}-
            ${{ runner.os }}-buildx-

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: https://ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.TOKEN }}

      - name: Build and push ${{ matrix.image }}
        id: docker_build
        uses: docker/build-push-action@v3
        with:
          context: .
          push: true
          tags: |
            ghcr.io/streamethorg/streameth-platform/${{ matrix.image }}:${{ needs.prepare-env.outputs.env_tag }}
            ghcr.io/streamethorg/streameth-platform/${{ matrix.image }}:${{ needs.prepare-env.outputs.env_tag }}-${{ github.sha }}
          file: ${{ matrix.dockerfile }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

  deploy:
    needs: [prepare-env, build-and-push-images]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H 145.223.118.217 >> ~/.ssh/known_hosts

      - name: Setup Docker context
        run: |
          mkdir -p ~/.docker/contexts
          if [[ ${{ github.ref }} == 'refs/heads/docker-prod' ]]; then
            echo "${{ secrets.DOCKER_CONTEXT_PROD_B64 }}" | base64 -d > ~/.docker/contexts/streameth-prod.tar.gz
            docker context import streameth-prod ~/.docker/contexts/streameth-prod.tar.gz
            docker context use streameth-prod
          else
            echo "${{ secrets.DOCKER_CONTEXT_STAGING_B64 }}" | base64 -d > ~/.docker/contexts/streameth-staging.tar.gz
            docker context import streameth-staging ~/.docker/contexts/streameth-staging.tar.gz
            docker context use streameth-staging
          fi

      # - name: Install docker-compose
      #   run: |
      #     sudo curl -L "https://github.com/docker/compose/releases/download/v2.23.3/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
      #     sudo chmod +x /usr/local/bin/docker-compose

      - name: Create .env file
        run: |
          cat << EOF > .env
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          EOF

      - name: Process and deploy compose file
        run: |
          STACK_NAME="${{ needs.prepare-env.outputs.stack_name }}"
          COMPOSE_FILE="${{ needs.prepare-env.outputs.compose_file }}"
          
          echo "üîç Debug: Using stack name: $STACK_NAME"
          echo "üîç Debug: Using compose file: $COMPOSE_FILE"
          
          # Install standalone docker-compose
          echo "üì• Installing docker-compose..."
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.23.3/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          
          # Create Python script to process the YAML
          echo "üìù Creating Python script..."
          cat << 'EOF' > process_compose.py
          import sys
          import yaml
          
          data = yaml.safe_load(sys.stdin)
          for service in data["services"].values():
              if "depends_on" in service:
                  service["depends_on"] = list(service["depends_on"].keys())
          yaml.dump(data, sys.stdout, default_flow_style=False)
          EOF
          
          # Process the compose file and convert depends_on to list format
          echo "üîÑ Processing compose file..."
          docker-compose -f $COMPOSE_FILE config | python3 process_compose.py > processed-compose.yml
          
          echo "üìä Processed file details:"
          ls -l processed-compose.yml
          echo "üìÑ First few lines of processed file:"
          head -n 10 processed-compose.yml
          
          echo "üöÄ Attempting to copy and deploy..."
          if [[ ${{ github.ref }} == 'refs/heads/docker-prod' ]]; then
            echo "üîµ Using production configuration"
            cat processed-compose.yml | ssh streameth@145.223.118.217 "echo 'üìù Writing compose file...' && \
              cat > /home/streameth/streameth/processed-compose.yml && \
              echo '‚úÖ File written, verifying...' && \
              ls -l /home/streameth/streameth/processed-compose.yml && \
              echo 'üöÄ Deploying stack...' && \
              docker stack deploy -c /home/streameth/streameth/processed-compose.yml --with-registry-auth $STACK_NAME && \
              echo '‚úÖ Deployment command completed'"
          else
            echo "üîµ Using staging configuration"
            cat processed-compose.yml | ssh streameth@145.223.118.217 "echo 'üìù Writing compose file...' && \
              cat > /home/streameth/streameth/processed-compose.yml && \
              echo '‚úÖ File written, verifying...' && \
              ls -l /home/streameth/streameth/processed-compose.yml && \
              echo 'üöÄ Deploying stack...' && \
              docker stack deploy -c /home/streameth/streameth/processed-compose.yml --with-registry-auth $STACK_NAME && \
              echo '‚úÖ Deployment command completed'"
          fi
          
          echo "üìã Deployment process completed"




      - name: Update services
        run: |
          STACK_NAME="${{ needs.prepare-env.outputs.stack_name }}"
          SHA="${{ github.sha }}"
          
          # Function to update a service and capture its exit status
          update_service() {
            local service=$1
            local temp_file=$(mktemp)
            if docker service update \
              --with-registry-auth \
              --image ghcr.io/streamethorg/streameth-platform/$service:${{ needs.prepare-env.outputs.env_tag }}-$SHA \
              ${STACK_NAME}_${service} > $temp_file 2>&1; then
              echo "‚úÖ Service ${STACK_NAME}_${service} updated successfully"
              rm $temp_file
              return 0
            else
              echo "‚ùå Failed to update ${STACK_NAME}_${service}"
              cat $temp_file
              rm $temp_file
              return 1
            fi
          }
          
          # Start all updates in parallel and capture PIDs
          pids=()
          for service in server stage-transcriptions session-transcriptions clips reel-creator; do
            update_service $service &
            pids+=($!)
          done
          
          # Wait for all updates and check for failures
          failed=0
          for pid in ${pids[@]}; do
            if ! wait $pid; then
              failed=1
            fi
          done
          
          # Exit with failure if any update failed
          exit $failed

      - name: Deploy router if needed
        if: github.ref == 'refs/heads/docker-prod'
        run: |
          if ! docker stack ls | grep -q "router"; then
            docker stack deploy -c /home/streameth/streameth/docker-compose.router.yml router
          fi

      - name: Cleanup processed compose file
        if: always()
        run: |
          ssh streameth@145.223.118.217 "rm -f /home/streameth/streameth/processed-compose.yml"
