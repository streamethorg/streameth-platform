name: Build server

on:
  push:
    branches: [docker, docker-prod, develop, main]

jobs:
  prepare-env:
    runs-on: ubuntu-latest
    outputs:
      env_tag: ${{ steps.set-tag.outputs.ENV_TAG }}
      compose_file: ${{ steps.set-tag.outputs.COMPOSE_FILE }}
      stack_name: ${{ steps.set-tag.outputs.STACK_NAME }}
    steps:
      - name: Set environment tag
        id: set-tag
        run: |
          if [[ ${{ github.ref }} == 'refs/heads/docker-prod' ]]; then
            echo "ENV_TAG=prod" >> $GITHUB_OUTPUT
            echo "COMPOSE_FILE=docker-compose.prod.yml" >> $GITHUB_OUTPUT
            echo "STACK_NAME=prod" >> $GITHUB_OUTPUT
          else
            echo "ENV_TAG=staging" >> $GITHUB_OUTPUT
            echo "COMPOSE_FILE=docker-compose.staging.yml" >> $GITHUB_OUTPUT
            echo "STACK_NAME=streameth-staging" >> $GITHUB_OUTPUT
          fi

  build-and-push-images:
    needs: prepare-env
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - image: server
            dockerfile: ./packages/server/src/Dockerfile
          - image: stage-transcriptions
            dockerfile: ./packages/server/workers/stage-transcriptions/Dockerfile
          - image: session-transcriptions
            dockerfile: ./packages/server/workers/session-transcriptions/Dockerfile
          - image: clips
            dockerfile: ./packages/server/workers/clips/Dockerfile
          - image: reel-creator
            dockerfile: ./packages/reel-creator/Dockerfile
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Add caching for Docker layers
      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ matrix.image }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-${{ matrix.image }}-
            ${{ runner.os }}-buildx-

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: https://ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.TOKEN }}

      - name: Build and push ${{ matrix.image }}
        id: docker_build
        uses: docker/build-push-action@v3
        with:
          context: .
          push: true
          tags: |
            ghcr.io/streamethorg/streameth-platform/${{ matrix.image }}:${{ needs.prepare-env.outputs.env_tag }}
            ghcr.io/streamethorg/streameth-platform/${{ matrix.image }}:${{ needs.prepare-env.outputs.env_tag }}-${{ github.sha }}
          file: ${{ matrix.dockerfile }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max

      # Temp fix for cache handling
      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

  deploy:
    needs: [prepare-env, build-and-push-images]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Setup SSH key
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H 145.223.118.217 >> ~/.ssh/known_hosts

      # Setup Docker context from base64-encoded secret
      - name: Setup Docker context
        run: |
          mkdir -p ~/.docker/contexts
          if [[ ${{ github.ref }} == 'refs/heads/docker-prod' ]]; then
            echo "${{ secrets.DOCKER_CONTEXT_PROD_B64 }}" | base64 -d > ~/.docker/contexts/streameth-prod.tar.gz
            docker context import streameth-prod ~/.docker/contexts/streameth-prod.tar.gz
            docker context use streameth-prod
          else
            echo "${{ secrets.DOCKER_CONTEXT_STAGING_B64 }}" | base64 -d > ~/.docker/contexts/streameth-staging.tar.gz
            docker context import streameth-staging ~/.docker/contexts/streameth-staging.tar.gz
            docker context use streameth-staging
          fi

      # Copy compose files to server
      - name: Copy compose files
        run: |
          scp docker-compose.*.yml streameth@145.223.118.217:/home/streameth/streameth/

      # Install envsubst if not present
      - name: Install envsubst
        run: |
          ssh streameth@145.223.118.217 "if ! command -v envsubst &> /dev/null; then sudo apt-get update && sudo apt-get install -y gettext-base; fi"

      # Log in to registry on deployment server
      - name: Log in to registry on deployment server
        run: |
          echo "${{ secrets.TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Deploy stack
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          STACK_NAME="${{ needs.prepare-env.outputs.stack_name }}"
          COMPOSE_FILE="${{ needs.prepare-env.outputs.compose_file }}"
          
          # First, create and process the compose file on the server, only replacing AWS variables
          ssh streameth@145.223.118.217 "cd /home/streameth/streameth && \
            export AWS_ACCESS_KEY_ID='${AWS_ACCESS_KEY_ID}' AWS_SECRET_ACCESS_KEY='${AWS_SECRET_ACCESS_KEY}' && \
            envsubst '\$AWS_ACCESS_KEY_ID \$AWS_SECRET_ACCESS_KEY' < ${COMPOSE_FILE} > temp-compose.yml"
          
          # Then deploy using the server path
          ssh streameth@145.223.118.217 "cd /home/streameth/streameth && \
            docker stack deploy \
              --with-registry-auth \
              -c temp-compose.yml \
              ${STACK_NAME}"
          
          # Clean up
          ssh streameth@145.223.118.217 "cd /home/streameth/streameth && rm temp-compose.yml"

      - name: Update services
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          STACK_NAME="${{ needs.prepare-env.outputs.stack_name }}"
          SHA="${{ github.sha }}"
          
          update_service() {
            local service=$1
            local temp_file=$(mktemp)
            if docker service update \
              --with-registry-auth \
              --image ghcr.io/streamethorg/streameth-platform/$service:${{ needs.prepare-env.outputs.env_tag }}-$SHA \
              --env-add "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}" \
              --env-add "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}" \
              ${STACK_NAME}_${service} > $temp_file 2>&1; then
              echo "✅ Service ${STACK_NAME}_${service} updated successfully"
              rm $temp_file
              return 0
            else
              echo "❌ Failed to update ${STACK_NAME}_${service}"
              cat $temp_file
              rm $temp_file
              return 1
            fi
          }
          
          pids=()
          for service in server stage-transcriptions session-transcriptions clips reel-creator; do
            update_service $service &
            pids+=($!)
          done
          
          failed=0
          for pid in ${pids[@]}; do
            if ! wait $pid; then
              failed=1
            fi
          done
          
          exit $failed

      # Deploy router if it doesn't exist (only needs to be done once)
      - name: Deploy router if needed
        if: github.ref == 'refs/heads/docker-prod'  # Only check/deploy router on prod branch pushes
        run: |
          if ! docker stack ls | grep -q "router"; then
            docker stack deploy -c /home/streameth/streameth/docker-compose.router.yml router
          fi
